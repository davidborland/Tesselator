<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <title>Tesselator</title>
  <script src="https://d3js.org/d3.v5.min.js"></script>
  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css">
</head>

<body>

<div class="jumbotron text-center">
  <h1>Tesselator</h1>
</div>

<div class="container-fluid text-center">
  <div class="row">
    <div class="col-2">
      <div>
        <h3>Controls</h3>
        <div class="form-group text-left">
          <label for="shapeSelect">Shape</label>
          <select class="form-control" id="shapeSelect">
            <option value="triangle">Triangle</option>
            <option value="square">Square</option>
            <option value="hexagon">Hexagon</option>
          </select>
        </div>
        <button type="button" class="btn btn-secondary form-control" id="resetButton">Reset</button>
      </div>
      <div class="mt-5">
        <h3>Vertices</h3>
        <div id="vertices" class="text-left"></div>
      </div>
    </div>
    <div class="col-5">
      <h3>Edit</h3>
      <div id="edit"><svg></svg></div>
    </div>
    <div class="col-5">
      <h3>Tesselation</h3>
      <div id="tile"><svg></svg></div>
    </div>
  </div>
  <div class="text-right small">
    <div>Author: David Borland, RENCI, UNC-Chapel Hill</div>
    <div><a href="https://github.com/davidborland/Tesselator">GitHub repository</a></div>
  </div>
</div>

<script type="text/javascript">

let shapeType = "triangle";
let shape = null;

// The current svg size
let size = getWidth();

let svgEdit = d3.select("#edit").select("svg")
    .attr("width", size)
    .attr("height", size);

let gEdit = svgEdit.append("g")
    .attr("transform", "translate(" + size / 2 + "," + size / 2 + ")scale(1,-1)");

gEdit.append("g").attr("class", "background");
gEdit.append("g").attr("class", "lines");
gEdit.append("g").attr("class", "points");

createBackground();

let svgTile = d3.select("#tile").select("svg")
    .attr("width", size)
    .attr("height", size);

svgTile.append("g")
    .attr("transform", "translate(" + size / 2 + "," + size / 2 + ")scale(1,-1)");

// Initialize shape
resetShape();

// Shape select
d3.select("#shapeSelect").on("change", () => {
  shapeType = d3.event.target.value;
  resetShape();
});

// Reset button
d3.select("#resetButton").on("click", resetShape);

function update() {
  updateEdit();
  updateTile();
  updateVertices();
}

function resetShape() {
  switch (shapeType) {
    case "triangle":
      shape = newTriangle();
      update();
      break;

    case "square":
      shape = newSquare();
      update();
      break;

    case "hexagon":
      shape = newHexagon();
      update();
      break;
  }
}

function createBackground() {  
  let activeLine = null;
  let drag1 = null;
  let drag2 = null;

  // Drag behavior
  const drag = d3.drag()
    .on("start", function() {      
      let mouse = d3.mouse(this);
      drag1 = { x: mouse[0], y: mouse[1] };

      let active = shape.lines.filter(d => d.active)[0];
      let twin = active.twin;

      let activeIndex = shape.lines.indexOf(active);
      let twinIndex = shape.lines.indexOf(twin);

      let v = { x: drag1.x - active.p1.x, y: drag1.y - active.p1.y };

      drag2 = { x: twin.p2.x + v.x, y: twin.p2.y + v.y };

      if (activeIndex > twinIndex) {
        shape.points.splice(twinIndex + 1, 0, drag2);
        shape.points.splice(activeIndex + 2, 0, drag1);
      }
      else {
        shape.points.splice(activeIndex + 1, 0, drag1);
        shape.points.splice(twinIndex + 2, 0, drag2);
      }

      let new1 = { p1: active.p1, p2: drag1 };
      let new2 = { p1: drag1, p2: active.p2 };
      let new3 = { p1: twin.p1, p2: drag2 };
      let new4 = { p1: drag2, p2: twin.p2 };

      new1.twin = new4;
      new2.twin = new3;
      new3.twin = new2;
      new4.twin = new1;

      let offset = twinIndex > activeIndex ? 1 : 0;
      shape.lines.splice(activeIndex, 1, new1, new2);
      shape.lines.splice(twinIndex + offset, 1, new3, new4);

      update();
    })
    .on("drag", function() {
      const i = shape.points.indexOf(drag1);

      let x = d3.event.x;
      let y = d3.event.y;

      let vx = x - drag1.x;
      let vy = y - drag1.y;

      drag1.x = x;
      drag1.y = y;

      drag2.x += vx;
      drag2.y += vy;

      update();
    })
    .on("end", function() {     
      drag1 = null;
      drag2 = null;
    });

  svgEdit.select(".background").append("rect")
      .attr("x", -size / 2)
      .attr("y", -size / 2)
      .attr("width", size)
      .attr("height", size)
      .style("visibility", "hidden")
      .style("pointer-events", "all")
      .on("mousemove", function() {
        // Mouse position
        let mp = d3.mouse(this);

        // Find closest line segment
        let closest = shape.lines.reduce((p, c, i) => {
          let p1 = [c.p1.x, c.p1.y];
          let p2 = [c.p2.x, c.p2.y];
          let d = pointLineSegmentDistance(mp, p1, p2);

          return p === null || d < p.d ? { i: i, d: d } : p;
        }, null);

        shape.lines.forEach(d => {
          d.active = false;
        });

        shape.lines[closest.i].active = true;

        update();
      })
      .on("mouseout", function() {
        shape.lines.forEach(d => {
          d.active = false;
        });

        update();
      })
      .on("click", function() {
      })
      .call(drag);
}

function updateEdit() {  
  let r = 5;

  // Drag behavior for control handles
  const drag = d3.drag()
    .on("start", function(d) {
      // Turn off mouse events for other handles while dragging
      gControl.selectAll(".handle").filter(function(e) { return e !== d; })
          .style("pointer-events", "none");
    })
    .on("drag", function(d, i) {
      let x = d3.event.x;
      let y = d3.event.y;

      let vx = x - d.x;
      let vy = y - d.y;

      d.x = x;
      d.y = y;

      let j = (i + 2) % shape.points.length;
      let p = shape.points[j];

      p.x += vx;
      p.y += vy; 

      update();
    })
    .on("end", function() {     
      // Turn mouse events back on for handles
      gControl.selectAll(".handle")
          .style("pointer-events", null);
    });

  // Draw points
  let point = svgEdit.select(".points").selectAll("circle")
      .data(shape.points);

  point.enter().append("circle")
      .attr("r", r)
      .style("pointer-events", "all")
    .merge(point)
      .attr("cx", d => d.x)
      .attr("cy", d => d.y)
      .style("fill", "#ac1a2f")
      .style("stroke", "black")
      .style("visibility", d => d.active ? "visible" : "hidden");
/*      
      .on("mouseover", function(d) {
        d.active = true;
        update();
      })
      .on("mouseout", function(d) {
        d.active = false;
        update();
      })
      .call(drag);
*/      
      
  point.exit().remove();

  // Draw lines
  let line = svgEdit.select(".lines").selectAll("line")
      .data(shape.lines);

  line.enter().append("line")
      .style("pointer-events", "none")
    .merge(line)
      .attr("x1", d => d.p1.x)
      .attr("y1", d => d.p1.y)
      .attr("x2", d => d.p2.x)
      .attr("y2", d => d.p2.y)
      .style("stroke", "black")
      .style("stroke-width", d => d.active ? 3 : 1)
      .style("stroke-linecap", "round");
      
  line.exit().remove();
}

function updateTile() {
  if (shapeType !== "square") return;

  let xExtent = d3.extent(shape.points, d => d.x);
  let yExtent = d3.extent(shape.points, d => d.y);

  xExtent = xExtent[1] - xExtent[0];
  yExtent = yExtent[1] - yExtent[0];

  let w = d3.max(shape.lines, d => {
    return Math.max(d.p1.x - d.twin.p2.x, d.p2.x - d.twin.p1.x);
  });

  let h = d3.max(shape.lines, d => {
    return Math.max(d.p1.y - d.twin.p2.y, d.p2.y - d.twin.p1.y);
  });

  let xSize = ySize = getWidth();
  xSize += xExtent * 2;
  ySize += yExtent * 2;

  let shapes = [];
  for (x = 0, i = 0; x < xSize; x += w, i++) {
    for (y = 0, j = 0; y < ySize; y += h, j++) {
      let s = copyShape(shape);
      translateShape(s, x, y);
      s.i = i;
      s.j = j;
      shapes.push(s);
    }
  }

  shapes.forEach(d => {
    translateShape(d, -xSize / 2, -ySize / 2);
  });

  let g = svgTile.select("g");

  // Draw polygons
  let polygon = g.selectAll("polygon")
      .data(shapes);

  polygon.enter().append("polygon")
      .style("stroke", "#666")
    .merge(polygon)
      .attr("points", points)
      .style("fill", fill);

  polygon.exit().remove();

  function points(d) {
    return d.points.map(d => {
      return d.x + "," + d.y;
    }).join(" ");
  }

  function fill(d) {
    return (d.i + (d.j % 2)) % 2 === 0 ? "#ac1a2f" : "black";
  }
}

function updateVertices() {
  let vertex = d3.select("#vertices").selectAll("p")
      .data(shape.points);

  vertex.enter().append("p").merge(vertex)
      .text(vertexText);

  vertex.exit().remove();

  function vertexText(d, i) {
    return "Vertex " + i + ": " + Math.round(d.x) + ", " + Math.round(d.y);
  }
}

function copyShape(shape) {
  let points = shape.points.map(d => ({ x: d.x, y: d.y }));
  
  return {
    points: points,
    lines: linesFromPoints(points)
  }
}

function translateShape(shape, x, y) {
  shape.points.forEach(d => {
    d.x += x;
    d.y += y;
  });
}

function newTriangle() {
  let s = size / 20;
  let a = 30 * Math.PI / 180;
  let x = Math.cos(a) * s;
  let y = Math.sin(a) * s;

  let points = [
    { x: 0, y: s },
    { x: x, y: -y },
    { x: -x, y: -y }
  ];

  return {
    points: points,
    lines: linesFromPoints(points)
  };
}

function newSquare() {
  let s = size / 20;

  let points = [
    { x: -s, y: s },
    { x: s, y: s },
    { x: s, y: -s },
    { x: -s, y: -s }
  ];

  let lines = linesFromPoints(points);

  lines[0].twin = lines[2];
  lines[1].twin = lines[3];
  lines[2].twin = lines[0];
  lines[3].twin = lines[1];

  return {
    points: points,
    lines: lines
  };
}

function newHexagon() {
  let s = size / 20;
  let a = 60 * Math.PI / 180;
  
  let points = d3.range(-a, 4.5 * a, a).map(d => {
    return {
      x: Math.cos(d) * s,
      y: Math.sin(d) * s
    };
  });

  return {
    points: points,
    lines: linesFromPoints(points)
  };
}

function getWidth() {
  return d3.select("#edit").node().clientWidth;
}

function linesFromPoints(points) {
  return d3.pairs(points.concat(points[0])).map(d => {
    return {
      p1: d[0],
      p2: d[1]
    };
  });
}

function distance(p1, p2) {
  return Math.sqrt(distance2(p1, p2));
}

function distance2(p1, p2) {
  const x = p1[0] - p2[0],
        y = p1[1] - p2[1];

  return x * x + y * y;
}

// Return the distance between a point p and a line segment p1p2
// Based on technique described here: http://paulbourke.net/geometry/pointlineplane/
function pointLineSegmentDistance(p, p1, p2) {
  return distance(p, pointLineSegmentClosestPoint(p, p1, p2));
}

function pointLineSegmentClosestPoint(p, p1, p2) {
  // Check for coincident p1 and p2
  if (p1[0] === p2[0] && p1[1] === p2[1]) {
    // Return one of the points
    return p1.slice();
  }

  // Compute u
  const u = ((p[0] - p1[0]) * (p2[0] - p1[0]) + (p[1] - p1[1]) * (p2[1] - p1[1])) /
            (Math.pow(p2[0] - p1[0], 2) + Math.pow(p2[1] - p1[1], 2));

  // Test u
  if (u >= 0 && u <= 1) {
    // In line segement, return closest point on line
    const p3 = [ p1[0] + u * (p2[0] - p1[0]),
                 p1[1] + u * (p2[1] - p1[1]) ];

    return p3;
  }
  else {
    // Return closest line segment end point
    return distance2(p, p1) < distance2(p, p2) ? p1.slice() : p2.slice();
  }
}

</script>

</body>
</html>
