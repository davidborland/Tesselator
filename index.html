<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <title>Tesselator</title>
  <script src="https://d3js.org/d3.v5.min.js"></script>
  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css">
</head>

<body>

<div class="jumbotron text-center">
  <h1>Tesselator</h1>
</div>

<div class="container-fluid text-center">
  <div class="row">
    <div id="controls" class="col-2">
      <h3>Controls</h3>
      <div class="form-group text-left">
        <label for="shapeSelect">Shape</label>
        <select class="form-control" id="shapeSelect">
          <option value="triangle">Triangle</option>
          <option value="square">Square</option>
          <option value="hexagon">Hexagon</option>
        </select>
      </div>
    </div>
    <div class="col-5">
      <h3>Edit</h3>
      <div id="edit">
        <svg></svg></div>
      <h3>Vertices</h3>
      <div id="vertices" class="text-left"></div>
    </div>
    <div class="col-5">
      <h3>Tesselation</h3>
      <div id="tile"><svg></svg></div>
    </div>
  </div>
  <div class="text-right small">
    <div>Author: David Borland, RENCI, UNC-Chapel Hill</div>
    <div><a href="https://github.com/davidborland/Tesselator">GitHub repository</a></div>
  </div>
</div>

<script type="text/javascript">

// Shape select
d3.select("#shapeSelect").on("change", () => {
  switch (d3.event.target.value) {
    case "triangle":
      shape = newTriangle();
      update();
      break;

    case "square":
      shape = newSquare();
      update();
      break;

    case "hexagon":
      shape = newHexagon();
      update();
      break;
  }
});

// The current svg size
let size = getWidth();

let svgEdit = d3.select("#edit").select("svg")
    .attr("width", size)
    .attr("height", size);

let gEdit = svgEdit.append("g")
    .attr("transform", "translate(" + size / 2 + "," + size / 2 + ")scale(1,-1)");

gEdit.append("g").append("rect").attr("class", "background")
    .attr("x", -size / 2)
    .attr("y", -size / 2)
    .attr("width", size)
    .attr("height", size)
    .style("visibility", "hidden")
    .style("pointer-events", "all")
    .on("mousemove", function() {
      // Mouse position
      let mp = d3.mouse(this);

      // Find closest line segment
      let closest = shape.lines.reduce((p, c, i) => {
        let p1 = [c.p1.x, c.p1.y];
        let p2 = [c.p2.x, c.p2.y];
        let d = pointLineSegmentDistance(mp, p1, p2);

        return p === null || d < p.d ? { i: i, d: d } : p;
      }, null);

      shape.lines.forEach(d => {
        d.active = false;
      });

      shape.lines[closest.i].active = true;

      update();
    })
    .on("mouseout", function() {
      shape.lines.forEach(d => {
        d.active = false;
      });

      update();
    })
    .on("click", function() {
      let mp = d3.mouse(this);
      mp = { x: mp[0], y: mp[1] };

      let active = shape.lines.filter(d => d.active)[0];
      let index = shape.lines.indexOf(active);

      shape.points.splice(index + 1, 0, mp);
      shape.lines = linesFromPoints(shape.points);

      update();
    });

gEdit.append("g").attr("class", "lines");
gEdit.append("g").attr("class", "points");

let svgTile = d3.select("#tile").select("svg")
    .attr("width", size)
    .attr("height", size);

svgTile.append("g")
    .attr("transform", "translate(" + size / 2 + "," + size / 2 + ")scale(1,-1)");

// The current shape
let shape = newTriangle();

// Initial update
update();

function update() {
  updateEdit();
  updateTile();
  updateVertices();
}

function updateEdit() {  
  let r = 5;

  // Drag behavior for control handles
  const drag = d3.drag()
    .on("start", function(d) {
      // Turn off mouse events for other handles while dragging
      //gControl.selectAll(".handle").filter(function(e) { return e !== d; })
      //    .style("pointer-events", "none");
    })
    .on("drag", function(d, i) {
      let x = d3.event.x;
      let y = d3.event.y;

      let vx = x - d.x;
      let vy = y - d.y;

      d.x = x;
      d.y = y;

      let j = (i + 2) % shape.points.length;
      let p = shape.points[j];

      p.x += vx;
      p.y += vy; 

      update();
    })
    .on("end", function() {     
      // Turn mouse events back on for handles
      //gControl.selectAll(".handle")
      //    .style("pointer-events", null);
    });

  // Draw points
  let point = svgEdit.select(".points").selectAll("circle")
      .data(shape.points);

  point.enter().append("circle")
      .attr("r", r)
      .style("pointer-events", "all")
    .merge(point)
      .attr("cx", d => d.x)
      .attr("cy", d => d.y)
      .style("fill", "#ac1a2f")
      .style("stroke", "black")
      .style("visibility", d => d.active ? "visible" : "hidden")
      .on("mouseover", function(d) {
        d.active = true;
        update();
      })
      .on("mouseout", function(d) {
        d.active = false;
        update();
      })
      .call(drag);
      
  point.exit().remove();

  // Draw lines
  let line = svgEdit.select(".lines").selectAll("line")
      .data(shape.lines);

  line.enter().append("line").merge(line)
      .attr("x1", d => d.p1.x)
      .attr("y1", d => d.p1.y)
      .attr("x2", d => d.p2.x)
      .attr("y2", d => d.p2.y)
      .style("stroke", "black")
      .style("stroke-width", d => d.active ? 3 : 1)
      .style("stroke-linecap", "round");
      
  line.exit().remove();
}

function updateTile() {
  let g = svgTile.select("g");

  // Draw polygons
  let polygon = g.selectAll("polygon")
      .data([shape]);

  polygon.enter().append("polygon")
      .style("stroke", "none")
    .merge(polygon)
      .attr("points", points)
      .style("fill", fill);

  polygon.exit().remove();

  function points(d) {
    return d.points.map(d => {
      return d.x + "," + d.y;
    }).join(" ");
  }

  function fill(d) {
    return "#ccc";
  }
}

function updateVertices() {
  let vertex = d3.select("#vertices").selectAll("p")
      .data(shape.points);

  vertex.enter().append("p").merge(vertex)
      .text(vertexText);

  vertex.exit().remove();

  function vertexText(d, i) {
    return "Vertex " + i + ": " + Math.round(d.x) + ", " + Math.round(d.y);
  }
}

function newTriangle() {
  let s = size / 20;
  let a = 30 * Math.PI / 180;
  let x = Math.cos(a) * s;
  let y = Math.sin(a) * s;

  let points = [
    { x: 0, y: s },
    { x: x, y: -y },
    { x: -x, y: -y }
  ];

  return {
    points: points,
    lines: linesFromPoints(points)
  };
}

function newSquare() {
  let s = size / 20;

  let points = [
    { x: -s, y: s },
    { x: s, y: s },
    { x: s, y: -s },
    { x: -s, y: -s }
  ];

  return {
    points: points,
    lines: linesFromPoints(points)
  };
}

function newHexagon() {
  let s = size / 20;
  let a = 60 * Math.PI / 180;
  
  let points = d3.range(-a, 4.5 * a, a).map(d => {
    return {
      x: Math.cos(d) * s,
      y: Math.sin(d) * s
    };
  });

  return {
    points: points,
    lines: linesFromPoints(points)
  };
}

function getWidth() {
  return d3.select("#edit").node().clientWidth;
}

function linesFromPoints(points) {
  return d3.pairs(points.concat(points[0])).map(d => {
    return {
      p1: d[0],
      p2: d[1]
    };
  });
}

function distance(p1, p2) {
  return Math.sqrt(distance2(p1, p2));
}

function distance2(p1, p2) {
  const x = p1[0] - p2[0],
        y = p1[1] - p2[1];

  return x * x + y * y;
}

// Return the distance between a point p and a line segment p1p2
// Based on technique described here: http://paulbourke.net/geometry/pointlineplane/
function pointLineSegmentDistance(p, p1, p2) {
  return distance(p, pointLineSegmentClosestPoint(p, p1, p2));
}

function pointLineSegmentClosestPoint(p, p1, p2) {
  // Check for coincident p1 and p2
  if (p1[0] === p2[0] && p1[1] === p2[1]) {
    // Return one of the points
    return p1.slice();
  }

  // Compute u
  const u = ((p[0] - p1[0]) * (p2[0] - p1[0]) + (p[1] - p1[1]) * (p2[1] - p1[1])) /
            (Math.pow(p2[0] - p1[0], 2) + Math.pow(p2[1] - p1[1], 2));

  // Test u
  if (u >= 0 && u <= 1) {
    // In line segement, return closest point on line
    const p3 = [ p1[0] + u * (p2[0] - p1[0]),
                 p1[1] + u * (p2[1] - p1[1]) ];

    return p3;
  }
  else {
    // Return closest line segment end point
    return distance2(p, p1) < distance2(p, p2) ? p1.slice() : p2.slice();
  }
}

</script>

</body>
</html>
